{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Qlient Core \u00b6 This is the core for a blazingly fast and modern graphql (async) client that was designed with simplicity in mind. Key Features \u00b6 Support both synchronous and asynchronous clients Automatic query generation Offline query validation Support for different backends Easily extend your client through plugins. Quick Preview \u00b6 from qlient.core import Client , Backend , GraphQLResponse class MyBackend ( Backend ): \"\"\"Must be implemented by you\"\"\" client = Client ( MyBackend ()) res : GraphQLResponse = client . query . get_my_thing ( \"name\" ) print ( res . request . query ) # \"query get_my_thing { get_my_thing { name } }\"","title":"Overview"},{"location":"#welcome-to-qlient-core","text":"This is the core for a blazingly fast and modern graphql (async) client that was designed with simplicity in mind.","title":"Welcome to Qlient Core"},{"location":"#key-features","text":"Support both synchronous and asynchronous clients Automatic query generation Offline query validation Support for different backends Easily extend your client through plugins.","title":"Key Features"},{"location":"#quick-preview","text":"from qlient.core import Client , Backend , GraphQLResponse class MyBackend ( Backend ): \"\"\"Must be implemented by you\"\"\" client = Client ( MyBackend ()) res : GraphQLResponse = client . query . get_my_thing ( \"name\" ) print ( res . request . query ) # \"query get_my_thing { get_my_thing { name } }\"","title":"Quick Preview"},{"location":"api/","text":"API \u00b6","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"installation/","text":"Installation \u00b6 Qlient is a pure-python module. This means that there is no C code which needs to be compiled. This package is build with poetry so installation is as you might expect. pip install qlient-core or using poetry poetry add qlient-core","title":"Installation"},{"location":"installation/#installation","text":"Qlient is a pure-python module. This means that there is no C code which needs to be compiled. This package is build with poetry so installation is as you might expect. pip install qlient-core or using poetry poetry add qlient-core","title":"Installation"},{"location":"introduction/","text":"Quick Introduction \u00b6 Walk-through \u00b6 Below is a walk-through for the implementation of a strawberry backend. If you do not want to follow the walk-through and just see the result, I suggest you skip to the full script . Otherwise, with no further ado lets get these fingers warm and ready for copy and paste. Creating the user type \u00b6 Let's start by creating a simple type we can query and mutate. import strawberry # must be installed separately @strawberry . type class User : name : str age : int Defining the data storage \u00b6 Next, we make a \"database\" that stores all our users. all_users : List [ User ] = [ User ( name = \"Patrick\" , age = 100 ) ] Creating the query type \u00b6 With an initial user in that list, we can now create the Query type and schema. @strawberry . type class Query : @strawberry . field async def get_users ( self ) -> List [ User ]: return all_users schema = strawberry . Schema ( query = Query ) Implement an AsyncBackend \u00b6 Now, moving on to creating the qlient Backend. from qlient.core import AsyncBackend , GraphQLRequest , GraphQLResponse class StrawberryBackend ( AsyncBackend ): async def execute_query ( self , request : GraphQLRequest ) -> GraphQLResponse : # get the result from the strawberry graphql schema result = await schema . execute ( query = request . query , operation_name = request . operation_name , variable_values = request . variables , root_value = request . root , context_value = request . context , ) # create the graphql response object return GraphQLResponse ( request , { \"data\" : result . data , \"errors\" : result . errors , \"extensions\" : result . extensions , } ) Create the AsyncClient \u00b6 And now finally, instantiating the Client: import asyncio from qlient.core import AsyncClient , GraphQLResponse async def main (): async with AsyncClient ( StrawberryBackend ()) as client : # strawberry automatically converts snake_case to camelCase result : GraphQLResponse = await client . query . getUsers ([ \"name\" , \"age\" ]) print ( result . data ) asyncio . run ( main ()) { \"getUsers\" : [ { \"name\" : \"Patrick\" , \"age\" : 100 } ] } Full Script \u00b6","title":"Introduction"},{"location":"introduction/#quick-introduction","text":"","title":"Quick Introduction"},{"location":"introduction/#walk-through","text":"Below is a walk-through for the implementation of a strawberry backend. If you do not want to follow the walk-through and just see the result, I suggest you skip to the full script . Otherwise, with no further ado lets get these fingers warm and ready for copy and paste.","title":"Walk-through"},{"location":"introduction/#creating-the-user-type","text":"Let's start by creating a simple type we can query and mutate. import strawberry # must be installed separately @strawberry . type class User : name : str age : int","title":"Creating the user type"},{"location":"introduction/#defining-the-data-storage","text":"Next, we make a \"database\" that stores all our users. all_users : List [ User ] = [ User ( name = \"Patrick\" , age = 100 ) ]","title":"Defining the data storage"},{"location":"introduction/#creating-the-query-type","text":"With an initial user in that list, we can now create the Query type and schema. @strawberry . type class Query : @strawberry . field async def get_users ( self ) -> List [ User ]: return all_users schema = strawberry . Schema ( query = Query )","title":"Creating the query type"},{"location":"introduction/#implement-an-asyncbackend","text":"Now, moving on to creating the qlient Backend. from qlient.core import AsyncBackend , GraphQLRequest , GraphQLResponse class StrawberryBackend ( AsyncBackend ): async def execute_query ( self , request : GraphQLRequest ) -> GraphQLResponse : # get the result from the strawberry graphql schema result = await schema . execute ( query = request . query , operation_name = request . operation_name , variable_values = request . variables , root_value = request . root , context_value = request . context , ) # create the graphql response object return GraphQLResponse ( request , { \"data\" : result . data , \"errors\" : result . errors , \"extensions\" : result . extensions , } )","title":"Implement an AsyncBackend"},{"location":"introduction/#create-the-asyncclient","text":"And now finally, instantiating the Client: import asyncio from qlient.core import AsyncClient , GraphQLResponse async def main (): async with AsyncClient ( StrawberryBackend ()) as client : # strawberry automatically converts snake_case to camelCase result : GraphQLResponse = await client . query . getUsers ([ \"name\" , \"age\" ]) print ( result . data ) asyncio . run ( main ()) { \"getUsers\" : [ { \"name\" : \"Patrick\" , \"age\" : 100 } ] }","title":"Create the AsyncClient"},{"location":"introduction/#full-script","text":"","title":"Full Script"},{"location":"usage/backend/","text":"Backends \u00b6 A backend is a service that can take a query, variables and an operation name to create a response. The most common backend is probably going to be some sort of web server. Writing Backends \u00b6 Although a GraphQL API is mostly used in combination with a http backend, it's not solely bound serve over http. For example when using strawberry you can generally just execute queries locally. import asyncio from typing import List import strawberry # must be installed separately from qlient.core import ( AsyncClient , AsyncBackend , GraphQLRequest , GraphQLResponse , ) @strawberry . type class User : name : str age : int all_users : List [ User ] = [ User ( name = \"Patrick\" , age = 100 )] @strawberry . type class Query : @strawberry . field async def get_users ( self ) -> List [ User ]: return all_users schema = strawberry . Schema ( query = Query ) class StrawberryBackend ( AsyncBackend ): async def execute_query ( self , request : GraphQLRequest ) -> GraphQLResponse : # get the result result = await schema . execute ( query = request . query , operation_name = request . operation_name , variable_values = request . variables , root_value = request . root , context_value = request . context , ) # create the graphql response object return GraphQLResponse ( request , { \"data\" : result . data , \"errors\" : result . errors , \"extensions\" : result . extensions , }, ) async def main (): async with AsyncClient ( StrawberryBackend ()) as client : # strawberry automatically converts snake_case to camelCase result : GraphQLResponse = await client . query . getUsers ([ \"name\" , \"age\" ]) print ( result . data ) if __name__ == \"__main__\" : asyncio . run ( main ()) (This script is complete and should run \"as is\") So what's going on here: After all imports are done the strawberry schema is created Once we have the schema, it's time to create our backend. For that we must import the base Backend class from qlient.backend . Then we implement the required abstract methods execute_query and add the cache_key property. (Later is used for using the client with a cache. But this is not necessary in this case.) Once we have our custom backend, all we have to do now is to create our client. Now we can use the client just like any other http client","title":"Backends"},{"location":"usage/backend/#backends","text":"A backend is a service that can take a query, variables and an operation name to create a response. The most common backend is probably going to be some sort of web server.","title":"Backends"},{"location":"usage/backend/#writing-backends","text":"Although a GraphQL API is mostly used in combination with a http backend, it's not solely bound serve over http. For example when using strawberry you can generally just execute queries locally. import asyncio from typing import List import strawberry # must be installed separately from qlient.core import ( AsyncClient , AsyncBackend , GraphQLRequest , GraphQLResponse , ) @strawberry . type class User : name : str age : int all_users : List [ User ] = [ User ( name = \"Patrick\" , age = 100 )] @strawberry . type class Query : @strawberry . field async def get_users ( self ) -> List [ User ]: return all_users schema = strawberry . Schema ( query = Query ) class StrawberryBackend ( AsyncBackend ): async def execute_query ( self , request : GraphQLRequest ) -> GraphQLResponse : # get the result result = await schema . execute ( query = request . query , operation_name = request . operation_name , variable_values = request . variables , root_value = request . root , context_value = request . context , ) # create the graphql response object return GraphQLResponse ( request , { \"data\" : result . data , \"errors\" : result . errors , \"extensions\" : result . extensions , }, ) async def main (): async with AsyncClient ( StrawberryBackend ()) as client : # strawberry automatically converts snake_case to camelCase result : GraphQLResponse = await client . query . getUsers ([ \"name\" , \"age\" ]) print ( result . data ) if __name__ == \"__main__\" : asyncio . run ( main ()) (This script is complete and should run \"as is\") So what's going on here: After all imports are done the strawberry schema is created Once we have the schema, it's time to create our backend. For that we must import the base Backend class from qlient.backend . Then we implement the required abstract methods execute_query and add the cache_key property. (Later is used for using the client with a cache. But this is not necessary in this case.) Once we have our custom backend, all we have to do now is to create our client. Now we can use the client just like any other http client","title":"Writing Backends"}]}