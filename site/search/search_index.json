{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Qlient Core \u00b6 This is the core for a blazingly fast and modern graphql (async) client that was designed with simplicity in mind. Key Features \u00b6 Support both synchronous and asynchronous clients Automatic query generation Offline query validation Support for different backends Easily extend your client through plugins. Quick Preview \u00b6 from qlient.core import Client , Backend , GraphQLResponse class MyBackend ( Backend ): \"\"\"Must be implemented by you\"\"\" client = Client ( MyBackend ()) res : GraphQLResponse = client . query . get_my_thing ( \"name\" ) print ( res . request . query ) # \"query get_my_thing { get_my_thing { name } }\"","title":"Overview"},{"location":"#welcome-to-qlient-core","text":"This is the core for a blazingly fast and modern graphql (async) client that was designed with simplicity in mind.","title":"Welcome to Qlient Core"},{"location":"#key-features","text":"Support both synchronous and asynchronous clients Automatic query generation Offline query validation Support for different backends Easily extend your client through plugins.","title":"Key Features"},{"location":"#quick-preview","text":"from qlient.core import Client , Backend , GraphQLResponse class MyBackend ( Backend ): \"\"\"Must be implemented by you\"\"\" client = Client ( MyBackend ()) res : GraphQLResponse = client . query . get_my_thing ( \"name\" ) print ( res . request . query ) # \"query get_my_thing { get_my_thing { name } }\"","title":"Quick Preview"},{"location":"examples/","text":"Examples \u00b6 To better show you what you can do once you have a suitable backend, I've created a few examples. These examples are all based on the official SWAPI GraphQL API . Query a film by id \u00b6 from qlient.core import GraphQLResponse , Client client = Client ( ... ) response : GraphQLResponse = client . query . film ( id = \"ZmlsbXM6MQ==\" ) print ( response . request . query ) (Which automatically selects fields and generates the following query) query film($id: ID) { film(id: $id) { title episodeID openingCrawl director producers releaseDate speciesConnection { totalCount } starshipConnection { totalCount } vehicleConnection { totalCount } characterConnection { totalCount } planetConnection { totalCount } created edited id } } Query all films with selection \u00b6 from qlient.core import GraphQLResponse , Fields , Client client = Client ( ... ) response : GraphQLResponse = client . query . allFilms ( Fields ( \"totalCount\" , films = [ \"id\" , \"title\" , \"director\" , \"releaseDate\" ]) ) print ( response . request . query ) (Which generates the following query) query allFilms { allFilms { totalCount films { id title director releaseDate } } }","title":"Examples"},{"location":"examples/#examples","text":"To better show you what you can do once you have a suitable backend, I've created a few examples. These examples are all based on the official SWAPI GraphQL API .","title":"Examples"},{"location":"examples/#query-a-film-by-id","text":"from qlient.core import GraphQLResponse , Client client = Client ( ... ) response : GraphQLResponse = client . query . film ( id = \"ZmlsbXM6MQ==\" ) print ( response . request . query ) (Which automatically selects fields and generates the following query) query film($id: ID) { film(id: $id) { title episodeID openingCrawl director producers releaseDate speciesConnection { totalCount } starshipConnection { totalCount } vehicleConnection { totalCount } characterConnection { totalCount } planetConnection { totalCount } created edited id } }","title":"Query a film by id"},{"location":"examples/#query-all-films-with-selection","text":"from qlient.core import GraphQLResponse , Fields , Client client = Client ( ... ) response : GraphQLResponse = client . query . allFilms ( Fields ( \"totalCount\" , films = [ \"id\" , \"title\" , \"director\" , \"releaseDate\" ]) ) print ( response . request . query ) (Which generates the following query) query allFilms { allFilms { totalCount films { id title director releaseDate } } }","title":"Query all films with selection"},{"location":"installation/","text":"Installation \u00b6 Qlient is a pure-python module. This means that there is no C code which needs to be compiled. This package is build with poetry so installation is as you might expect. pip install qlient-core or using poetry poetry add qlient-core","title":"Installation"},{"location":"installation/#installation","text":"Qlient is a pure-python module. This means that there is no C code which needs to be compiled. This package is build with poetry so installation is as you might expect. pip install qlient-core or using poetry poetry add qlient-core","title":"Installation"},{"location":"introduction/","text":"Quick Introduction \u00b6 Walk-through \u00b6 Below is a walk-through for the implementation of a strawberry backend. If you do not want to follow the walk-through and just see the result, I suggest you skip to the full script . Otherwise, with no further ado lets get these fingers warm and ready for copy and paste. Creating the user type \u00b6 First things first, we have to set up everything related to the strawberry schema. Let's start by creating a simple User type we can query and mutate. import strawberry # must be installed separately @strawberry . type class User : \"\"\"The User object\"\"\" name : str age : int Defining the data storage \u00b6 Next, we make a \"database\" that stores all our users. all_users : List [ User ] = [ User ( name = \"Patrick\" , age = 100 ), User ( name = \"Daniel\" , age = 9999 ), ] Creating the query type \u00b6 With a few initial users in that list, we can now create the Query type and schema. @strawberry . type class Query : \"\"\"The strawberry query type\"\"\" @strawberry . field async def get_user ( self , index : int ) -> Optional [ User ]: \"\"\"Get a user by index\"\"\" try : return all_users [ index ] except IndexError : return None @strawberry . field async def get_users ( self ) -> List [ User ]: \"\"\"Get all users\"\"\" return all_users my_schema = strawberry . Schema ( query = Query ) Implement an AsyncBackend \u00b6 Now, moving on to creating the qlient Backend. from qlient.core import AsyncBackend , GraphQLRequest , GraphQLResponse class StrawberryBackend ( AsyncBackend ): \"\"\"The strawberry backend\"\"\" def __init__ ( self , schema : strawberry . Schema ): self . schema = schema async def execute_query ( self , request : GraphQLRequest ) -> GraphQLResponse : \"\"\"Execute a query on this backend\"\"\" result = await self . schema . execute ( query = request . query , operation_name = request . operation_name , variable_values = request . variables , root_value = request . root , context_value = request . context , ) # create the graphql response object return GraphQLResponse ( request , { \"data\" : result . data , \"errors\" : result . errors , \"extensions\" : result . extensions , }, ) Create the AsyncClient \u00b6 And now finally, instantiating the Client: import asyncio from qlient.core import AsyncClient , GraphQLResponse async def main (): \"\"\"The main coroutine\"\"\" async with AsyncClient ( StrawberryBackend ( my_schema )) as client : # strawberry automatically converts snake_case to camelCase result_1 : GraphQLResponse = await client . query . getUsers ([ \"name\" , \"age\" ]) print ( result_1 . data ) result_2 : GraphQLResponse = await client . query . getUser ( index = 1 ) print ( result_2 . data ) asyncio . run ( main ()) (result_1.data) { \"getUsers\" : [ { \"name\" : \"Patrick\" , \"age\" : 100 }, { \"name\" : \"Daniel\" , \"age\" : 9999 } ] } (result_2.data) { \"getUser\" : { \"name\" : \"Daniel\" , \"age\" : 9999 } } Full Script \u00b6 import asyncio from typing import List , Optional import strawberry # must be installed separately from qlient.core import ( AsyncClient , AsyncBackend , GraphQLRequest , GraphQLResponse , ) @strawberry . type class User : \"\"\"The User object\"\"\" name : str age : int all_users : List [ User ] = [ User ( name = \"Patrick\" , age = 100 ), User ( name = \"Daniel\" , age = 9999 ), ] @strawberry . type class Query : \"\"\"The strawberry query type\"\"\" @strawberry . field async def get_user ( self , index : int ) -> Optional [ User ]: \"\"\"Get a user by index\"\"\" try : return all_users [ index ] except IndexError : return None @strawberry . field async def get_users ( self ) -> List [ User ]: \"\"\"Get all users\"\"\" return all_users my_schema = strawberry . Schema ( query = Query ) class StrawberryBackend ( AsyncBackend ): \"\"\"The strawberry backend\"\"\" def __init__ ( self , schema : strawberry . Schema ): self . schema = schema async def execute_query ( self , request : GraphQLRequest ) -> GraphQLResponse : \"\"\"Execute a query on this backend\"\"\" result = await self . schema . execute ( query = request . query , operation_name = request . operation_name , variable_values = request . variables , root_value = request . root , context_value = request . context , ) # create the graphql response object return GraphQLResponse ( request , { \"data\" : result . data , \"errors\" : result . errors , \"extensions\" : result . extensions , }, ) async def main (): \"\"\"The main coroutine\"\"\" async with AsyncClient ( StrawberryBackend ( my_schema )) as client : # strawberry automatically converts snake_case to camelCase result_1 : GraphQLResponse = await client . query . getUsers ([ \"name\" , \"age\" ]) print ( result_1 . data ) result_2 : GraphQLResponse = await client . query . getUser ( index = 1 ) print ( result_2 . data ) asyncio . run ( main ())","title":"Introduction"},{"location":"introduction/#quick-introduction","text":"","title":"Quick Introduction"},{"location":"introduction/#walk-through","text":"Below is a walk-through for the implementation of a strawberry backend. If you do not want to follow the walk-through and just see the result, I suggest you skip to the full script . Otherwise, with no further ado lets get these fingers warm and ready for copy and paste.","title":"Walk-through"},{"location":"introduction/#creating-the-user-type","text":"First things first, we have to set up everything related to the strawberry schema. Let's start by creating a simple User type we can query and mutate. import strawberry # must be installed separately @strawberry . type class User : \"\"\"The User object\"\"\" name : str age : int","title":"Creating the user type"},{"location":"introduction/#defining-the-data-storage","text":"Next, we make a \"database\" that stores all our users. all_users : List [ User ] = [ User ( name = \"Patrick\" , age = 100 ), User ( name = \"Daniel\" , age = 9999 ), ]","title":"Defining the data storage"},{"location":"introduction/#creating-the-query-type","text":"With a few initial users in that list, we can now create the Query type and schema. @strawberry . type class Query : \"\"\"The strawberry query type\"\"\" @strawberry . field async def get_user ( self , index : int ) -> Optional [ User ]: \"\"\"Get a user by index\"\"\" try : return all_users [ index ] except IndexError : return None @strawberry . field async def get_users ( self ) -> List [ User ]: \"\"\"Get all users\"\"\" return all_users my_schema = strawberry . Schema ( query = Query )","title":"Creating the query type"},{"location":"introduction/#implement-an-asyncbackend","text":"Now, moving on to creating the qlient Backend. from qlient.core import AsyncBackend , GraphQLRequest , GraphQLResponse class StrawberryBackend ( AsyncBackend ): \"\"\"The strawberry backend\"\"\" def __init__ ( self , schema : strawberry . Schema ): self . schema = schema async def execute_query ( self , request : GraphQLRequest ) -> GraphQLResponse : \"\"\"Execute a query on this backend\"\"\" result = await self . schema . execute ( query = request . query , operation_name = request . operation_name , variable_values = request . variables , root_value = request . root , context_value = request . context , ) # create the graphql response object return GraphQLResponse ( request , { \"data\" : result . data , \"errors\" : result . errors , \"extensions\" : result . extensions , }, )","title":"Implement an AsyncBackend"},{"location":"introduction/#create-the-asyncclient","text":"And now finally, instantiating the Client: import asyncio from qlient.core import AsyncClient , GraphQLResponse async def main (): \"\"\"The main coroutine\"\"\" async with AsyncClient ( StrawberryBackend ( my_schema )) as client : # strawberry automatically converts snake_case to camelCase result_1 : GraphQLResponse = await client . query . getUsers ([ \"name\" , \"age\" ]) print ( result_1 . data ) result_2 : GraphQLResponse = await client . query . getUser ( index = 1 ) print ( result_2 . data ) asyncio . run ( main ()) (result_1.data) { \"getUsers\" : [ { \"name\" : \"Patrick\" , \"age\" : 100 }, { \"name\" : \"Daniel\" , \"age\" : 9999 } ] } (result_2.data) { \"getUser\" : { \"name\" : \"Daniel\" , \"age\" : 9999 } }","title":"Create the AsyncClient"},{"location":"introduction/#full-script","text":"import asyncio from typing import List , Optional import strawberry # must be installed separately from qlient.core import ( AsyncClient , AsyncBackend , GraphQLRequest , GraphQLResponse , ) @strawberry . type class User : \"\"\"The User object\"\"\" name : str age : int all_users : List [ User ] = [ User ( name = \"Patrick\" , age = 100 ), User ( name = \"Daniel\" , age = 9999 ), ] @strawberry . type class Query : \"\"\"The strawberry query type\"\"\" @strawberry . field async def get_user ( self , index : int ) -> Optional [ User ]: \"\"\"Get a user by index\"\"\" try : return all_users [ index ] except IndexError : return None @strawberry . field async def get_users ( self ) -> List [ User ]: \"\"\"Get all users\"\"\" return all_users my_schema = strawberry . Schema ( query = Query ) class StrawberryBackend ( AsyncBackend ): \"\"\"The strawberry backend\"\"\" def __init__ ( self , schema : strawberry . Schema ): self . schema = schema async def execute_query ( self , request : GraphQLRequest ) -> GraphQLResponse : \"\"\"Execute a query on this backend\"\"\" result = await self . schema . execute ( query = request . query , operation_name = request . operation_name , variable_values = request . variables , root_value = request . root , context_value = request . context , ) # create the graphql response object return GraphQLResponse ( request , { \"data\" : result . data , \"errors\" : result . errors , \"extensions\" : result . extensions , }, ) async def main (): \"\"\"The main coroutine\"\"\" async with AsyncClient ( StrawberryBackend ( my_schema )) as client : # strawberry automatically converts snake_case to camelCase result_1 : GraphQLResponse = await client . query . getUsers ([ \"name\" , \"age\" ]) print ( result_1 . data ) result_2 : GraphQLResponse = await client . query . getUser ( index = 1 ) print ( result_2 . data ) asyncio . run ( main ())","title":"Full Script"},{"location":"usage/backend/","text":"Backends \u00b6 A backend is a service that can take a query, variables and an operation name to create a response. The most common backend is probably going to be some sort of web server. Writing Backends \u00b6 Although a GraphQL API is mostly used in combination with a http backend, it's not solely bound serve over http. For example when using strawberry you can generally just execute queries locally. import asyncio from typing import List , Optional import strawberry # must be installed separately from qlient.core import ( AsyncClient , AsyncBackend , GraphQLRequest , GraphQLResponse , ) @strawberry . type class User : \"\"\"The User object\"\"\" name : str age : int all_users : List [ User ] = [ User ( name = \"Patrick\" , age = 100 ), User ( name = \"Daniel\" , age = 9999 ), ] @strawberry . type class Query : \"\"\"The strawberry query type\"\"\" @strawberry . field async def get_user ( self , index : int ) -> Optional [ User ]: \"\"\"Get a user by index\"\"\" try : return all_users [ index ] except IndexError : return None @strawberry . field async def get_users ( self ) -> List [ User ]: \"\"\"Get all users\"\"\" return all_users my_schema = strawberry . Schema ( query = Query ) class StrawberryBackend ( AsyncBackend ): \"\"\"The strawberry backend\"\"\" def __init__ ( self , schema : strawberry . Schema ): self . schema = schema async def execute_query ( self , request : GraphQLRequest ) -> GraphQLResponse : \"\"\"Execute a query on this backend\"\"\" result = await self . schema . execute ( query = request . query , operation_name = request . operation_name , variable_values = request . variables , root_value = request . root , context_value = request . context , ) # create the graphql response object return GraphQLResponse ( request , { \"data\" : result . data , \"errors\" : result . errors , \"extensions\" : result . extensions , }, ) async def main (): \"\"\"The main coroutine\"\"\" async with AsyncClient ( StrawberryBackend ( my_schema )) as client : # strawberry automatically converts snake_case to camelCase result_1 : GraphQLResponse = await client . query . getUsers ([ \"name\" , \"age\" ]) print ( result_1 . data ) result_2 : GraphQLResponse = await client . query . getUser ( index = 1 ) print ( result_2 . data ) asyncio . run ( main ()) (This script is complete and should run \"as is\")","title":"Backends"},{"location":"usage/backend/#backends","text":"A backend is a service that can take a query, variables and an operation name to create a response. The most common backend is probably going to be some sort of web server.","title":"Backends"},{"location":"usage/backend/#writing-backends","text":"Although a GraphQL API is mostly used in combination with a http backend, it's not solely bound serve over http. For example when using strawberry you can generally just execute queries locally. import asyncio from typing import List , Optional import strawberry # must be installed separately from qlient.core import ( AsyncClient , AsyncBackend , GraphQLRequest , GraphQLResponse , ) @strawberry . type class User : \"\"\"The User object\"\"\" name : str age : int all_users : List [ User ] = [ User ( name = \"Patrick\" , age = 100 ), User ( name = \"Daniel\" , age = 9999 ), ] @strawberry . type class Query : \"\"\"The strawberry query type\"\"\" @strawberry . field async def get_user ( self , index : int ) -> Optional [ User ]: \"\"\"Get a user by index\"\"\" try : return all_users [ index ] except IndexError : return None @strawberry . field async def get_users ( self ) -> List [ User ]: \"\"\"Get all users\"\"\" return all_users my_schema = strawberry . Schema ( query = Query ) class StrawberryBackend ( AsyncBackend ): \"\"\"The strawberry backend\"\"\" def __init__ ( self , schema : strawberry . Schema ): self . schema = schema async def execute_query ( self , request : GraphQLRequest ) -> GraphQLResponse : \"\"\"Execute a query on this backend\"\"\" result = await self . schema . execute ( query = request . query , operation_name = request . operation_name , variable_values = request . variables , root_value = request . root , context_value = request . context , ) # create the graphql response object return GraphQLResponse ( request , { \"data\" : result . data , \"errors\" : result . errors , \"extensions\" : result . extensions , }, ) async def main (): \"\"\"The main coroutine\"\"\" async with AsyncClient ( StrawberryBackend ( my_schema )) as client : # strawberry automatically converts snake_case to camelCase result_1 : GraphQLResponse = await client . query . getUsers ([ \"name\" , \"age\" ]) print ( result_1 . data ) result_2 : GraphQLResponse = await client . query . getUser ( index = 1 ) print ( result_2 . data ) asyncio . run ( main ()) (This script is complete and should run \"as is\")","title":"Writing Backends"},{"location":"usage/fields/","text":"Fields and Directives \u00b6 The Fields class is a powerful class for making nested or pre-configured field selections. In combination with the Field class you can create every query you need. Using the Fields Class \u00b6 from qlient.core import Fields nested_fields = Fields ( \"first_name\" , # will be converted to Field(\"first_name\") \"last_name\" , # will be converted to Field(\"first_name\") # This will be converted to # Field( # \"hobby\", # _sub_fields=Fields( # Field(\"name\"), # Field(\"club\", _sub_fields=Fields(Field(\"name\"))) # ) # ) hobby = Fields ( \"name\" , club = \"name\" ), ) # last_name first_name hobby { name club { name } } Supported Operators \u00b6 Both, the Field and Fields class currently support the following operators: Addition \u00b6 from qlient.core import Fields , Field name_fields = Fields ( \"first_name\" , \"last_name\" ) age_field = Field ( \"age\" ) person_fields = name_fields + age_field # { first_name last_name age } Combination of Fields and Field \u00b6 from qlient.core import Fields , Field , Directive my_home_world_selection = Fields ( \"id\" , \"name\" , \"population\" ) my_person_selection = Fields ( \"id\" , # will be converted to Field(\"id\") Field ( \"name\" ), Field ( \"height\" , _alias = \"my_height\" ), Field ( \"homeworld\" , _sub_fields = my_home_world_selection , _directive = Directive ( \"include\" ), ), ) # Every variable name used in a Field or Directive # is automatically generated and therefore unique. # { # id # name # my_height: height # homeworld @include { # id # name # population # } # }","title":"Fields and Directives"},{"location":"usage/fields/#fields-and-directives","text":"The Fields class is a powerful class for making nested or pre-configured field selections. In combination with the Field class you can create every query you need.","title":"Fields and Directives"},{"location":"usage/fields/#using-the-fields-class","text":"from qlient.core import Fields nested_fields = Fields ( \"first_name\" , # will be converted to Field(\"first_name\") \"last_name\" , # will be converted to Field(\"first_name\") # This will be converted to # Field( # \"hobby\", # _sub_fields=Fields( # Field(\"name\"), # Field(\"club\", _sub_fields=Fields(Field(\"name\"))) # ) # ) hobby = Fields ( \"name\" , club = \"name\" ), ) # last_name first_name hobby { name club { name } }","title":"Using the Fields Class"},{"location":"usage/fields/#supported-operators","text":"Both, the Field and Fields class currently support the following operators:","title":"Supported Operators"},{"location":"usage/fields/#addition","text":"from qlient.core import Fields , Field name_fields = Fields ( \"first_name\" , \"last_name\" ) age_field = Field ( \"age\" ) person_fields = name_fields + age_field # { first_name last_name age }","title":"Addition"},{"location":"usage/fields/#combination-of-fields-and-field","text":"from qlient.core import Fields , Field , Directive my_home_world_selection = Fields ( \"id\" , \"name\" , \"population\" ) my_person_selection = Fields ( \"id\" , # will be converted to Field(\"id\") Field ( \"name\" ), Field ( \"height\" , _alias = \"my_height\" ), Field ( \"homeworld\" , _sub_fields = my_home_world_selection , _directive = Directive ( \"include\" ), ), ) # Every variable name used in a Field or Directive # is automatically generated and therefore unique. # { # id # name # my_height: height # homeworld @include { # id # name # population # } # }","title":"Combination of Fields and Field"},{"location":"usage/plugins/","text":"Plugins \u00b6 You can write plugins for qlient which can be used to process/modify data before it is sent to ( pre ) and after it is received from ( post ) the backend. Writing a plugin is really simple and best explained via an example. from qlient.core import Plugin , GraphQLRequest , GraphQLResponse class MyLoggingPlugin ( Plugin ): def pre ( self , request : GraphQLRequest ) -> GraphQLRequest : print ( f \"About to send { request } to the backend\" ) return request def post ( self , response : GraphQLResponse ) -> GraphQLResponse : print ( f \"Received { response } from the backend\" ) return response A plugin can implement two methods: pre and post . The pre method receives the request as input and should always return a request. In contrast, the post method receives the response from the backend and should always return a response. To register this plugin you need to pass it to the client. Plugins are always executed sequentially. from qlient.core import Client client = Client ( ... , plugins = [ MyLoggingPlugin ()])","title":"Plugins"},{"location":"usage/plugins/#plugins","text":"You can write plugins for qlient which can be used to process/modify data before it is sent to ( pre ) and after it is received from ( post ) the backend. Writing a plugin is really simple and best explained via an example. from qlient.core import Plugin , GraphQLRequest , GraphQLResponse class MyLoggingPlugin ( Plugin ): def pre ( self , request : GraphQLRequest ) -> GraphQLRequest : print ( f \"About to send { request } to the backend\" ) return request def post ( self , response : GraphQLResponse ) -> GraphQLResponse : print ( f \"Received { response } from the backend\" ) return response A plugin can implement two methods: pre and post . The pre method receives the request as input and should always return a request. In contrast, the post method receives the response from the backend and should always return a response. To register this plugin you need to pass it to the client. Plugins are always executed sequentially. from qlient.core import Client client = Client ( ... , plugins = [ MyLoggingPlugin ()])","title":"Plugins"},{"location":"usage/proxies/","text":"The *ServiceProxy Objects \u00b6 The *ServiceProxy objects ( QueryServiceProxy , ...) are simple objects that check if an operation exists for the attribute or item requested. If the operation exists then it will return a *OperationProxy object (callable) that is responsible for creating the request and sending it to the backend. from qlient.core import Client client = Client ( ... ) # \"query\" is a QueryServiceProxy object. # It will check if there is an operation # with the name \"X\" defined in the query type # and if that is the case it will return an QueryOperationProxy. client . query . X () # The operation cal also be called via an __getitem__ call. # This is useful if the operation name is not a valid # python attribute name. client . query [ \"X-Y\" ]() Create the raw request \u00b6 from qlient.core import Client , GraphQLRequest client = Client ( ... ) request : GraphQLRequest = client . query . X . create_request ([ \"foo\" , \"bar\" ], foo = \"test\" ) print ( request . query ) # \"query X($foo: String) { X(foo: $foo) { foo bar } }\" print ( request . variables ) # {\"foo\": \"test\"}","title":"Proxies"},{"location":"usage/proxies/#the-serviceproxy-objects","text":"The *ServiceProxy objects ( QueryServiceProxy , ...) are simple objects that check if an operation exists for the attribute or item requested. If the operation exists then it will return a *OperationProxy object (callable) that is responsible for creating the request and sending it to the backend. from qlient.core import Client client = Client ( ... ) # \"query\" is a QueryServiceProxy object. # It will check if there is an operation # with the name \"X\" defined in the query type # and if that is the case it will return an QueryOperationProxy. client . query . X () # The operation cal also be called via an __getitem__ call. # This is useful if the operation name is not a valid # python attribute name. client . query [ \"X-Y\" ]()","title":"The *ServiceProxy Objects"},{"location":"usage/proxies/#create-the-raw-request","text":"from qlient.core import Client , GraphQLRequest client = Client ( ... ) request : GraphQLRequest = client . query . X . create_request ([ \"foo\" , \"bar\" ], foo = \"test\" ) print ( request . query ) # \"query X($foo: String) { X(foo: $foo) { foo bar } }\" print ( request . variables ) # {\"foo\": \"test\"}","title":"Create the raw request"}]}